
# FP, Labmda, Stream API
+ [1. Что такое lamdba выражение](#1.-Что-такое-lamdba-выражение)
+ [2. Что такое функциональные интерфейсы](##-2.-Что-такое-функциональные-интерфейсы)
+ [3. Перечислите функциональные интерфейсы из пакета java.util.function](#Перечислите-функциональные-интерфейсы-из-пакета-java.util.function.)
+ [Что такое _«наследование»_?](#Что-такое-наследование)
+ [Что такое _«полиморфизм»_?](#Что-такое-полиморфизм)
+ [Что такое _«абстракция»_?](#Что-такое-абстракция)
+ [Что представляет собой _«обмен сообщениями»_?](#Что-представляет-собой-обмен-сообщениями)
+ [Расскажите про основные понятия ООП: _«класс»_, _«объект»_, _«интерфейс»_.](#Расскажите-про-основные-понятия-ООП-класс-объект-интерфейс)
+ [В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?](#В-чем-заключаются-преимущества-и-недостатки-объектно-ориентированного-подхода-в-программировании)
+ [Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?](#Что-подразумевают-в-плане-принципов-ООП-выражения-является-и-имеет)
+ [В чем разница между _композицией_ и _агрегацией_?](#В-чем-разница-между-композицией-и-агрегацией)
+ [Что такое _статическое_ и _динамическое связывание_?](#Что-такое-статическое-и-динамическое-связывание)

## В чем разница между _композицией_ и _агрегацией_?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».

## 1. Что такое lamdba выражение
	Лямбда-выражение представляет собой блок кода,
	который можно передать в другое место, поэтому он может быть выполнен позже,
	один или несколько раз
	
	[к оглавлению](# FP, Labmda, Stream API)

## 2. Что такое функциональные интерфейсы
	 Это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.
	 Такой интерфейс описываем классическую математическую функцию.
	 Таким образом функциональный интерфейс может содержать так же default и static методы.
	 К функциональному интерфейсу можно добавить аннотацию @FunctionalInterface

## 3. Перечислите функциональные интерфейсы из пакета java.util.function.
    https://metanit.com/java/tutorial/9.3.php
    Consumer<T>, Function<T,R>, Predicate<T>, Supplier<T>, UnaryOperator<T> BinaryOperator<T> и их Bi – формы

    Predicate<T> - проверяет соблюдение некоторого условия.
    Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T

    BinaryOperator<T> - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
    и возвращает ее результат также в виде объекта типа T

    UnaryOperator<T> - принимает в качестве параметра объект типа T,
    выполняет над ними операции и возвращает результат операций в виде объекта типа T

    Function<T,R> - представляет функцию перехода от объекта типа T к объекту типа R

    Consumer<T> - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая

    Supplier<T> - принимает никаких аргументов, но должен возвращать объект типа T


## 4. Что такое функции высшего порядка?
    Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают другие функции в качестве своих результатов.
    У языка Java — возможно, последнего среди популярных языков — наконец-то появились функции высшего порядка в форме т. н. лямбда-выражений.

## 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?
    Также метод в Java может возвращать лямбда-выражение.


## 6. Что такое ссылки на методы?
    Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
    В принципе данный способ аналогичен передаче в метод лямбда-выражения.
    Ссылка на метод передается в виде имя_класса::имя_статического_метода (если метод статический)
    или объект_класса::имя_метода (если метод нестатический).

## 7. Что такое ссылки на конструкторы?
    можено в качестве параметров использовать конструкторы: название_класса::new
    При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
    что и конструкторы класса, и должны возвращать объект данного класса.

## 8. Расскажите о зоне видимости переменных в lamdba - выражениях?
    Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили.
    Но доступ возможен только при условии, что переменные являются effective final,
    то есть либо явно имеют модификатор final, либо не меняют своего значения после инициализации

## 9. Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение?
    Лямбда-выражение может генерировать исключение. Но если оно генерирует проверяемое исключение,
    то последнее должно быть совместимо с исключениями, перечисленными в выражении throws
    из объявления абстрактного метода в функциональном интерфейсе, либо можно поймать исключение в теле лямбда-выражения.
    Как известно из функциональных интерфейсов в Stream API нельзя выбрасывать контролируемые исключения.
    Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
    приходится оборачивать их в RuntimeException.
    https://www.codeflow.site/ru/article/java-lambda-exceptions

## 10. Что такое Stream API?
    Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности,
    упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API
    сосредоточена в пакете java.util.stream. Ключевым понятием в Stream API является поток данных.
    Поток представляет канал передачи данных из источника данных.
    Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.
    Одной из отличительных черт Stream API является применение лямбда-выражений.
    При работе со Stream API важно понимать, что все операции с потоками бывают либо терминальными (terminal),
    либо промежуточными (intermediate). Промежуточные операции возвращают трансформированный поток.
    Например, выше в примере метод filter принимал поток чисел и возвращал уже преобразованный поток,
    в котором только числа больше 0. К возвращенному потоку также можно применить ряд промежуточных операций.
    Конечные или терминальные операции возвращают конкретный результат.

## 11. Расскажите, как шаблон проектирования используется внутри Stream API?
    Используется паттерн стратегия - алгоритм выбирается во время выполнения.
    https://www.baeldung.com/java-strategy-pattern

## 12. Что делаем метод filter?
    Представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде объекта Predicate<T>
     и возвращает новый поток из элементов, которые удовлетворяют этому условию

## 13. Что делаем метод map
    Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
    то есть получить из элемента одного типа элемент другого типа.
    Для отображения используется метод map, который имеет следующее определение:
    <R> Stream<R> map(Function<? super T, ? extends R> mapper)
    Передаваемая в метод map функция задает преобразование от объектов типа T к типу R.
    И в результате возвращается новый поток с преобразованными объектами.

## 14. Что делаем метод flatMap?
    Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько.
    Данную операцию выполняет метод flatMap:
    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
    Например, в примере выше мы выводим название телефона и его цену.
    Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки.
    То есть из одного объекта Phone нам надо получить два объекта с информацией, например, в виде строки.
    Для этого применим flatMap:

    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                    new Phone("Samsung Galaxy S 6", 40000));

    phoneStream
        .flatMap(p->Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
        ))
        .forEach(s->System.out.println(s));

## 15. Что делаем метод collect?
    Преобразует поток в коллекцию. Мы можем написать свою реализацию функции, однако Java уже предоставляет
    ряд встроенных функций, определенных в классе Collectors:
    toList(): преобразование к типу List
    toSet(): преобразование к типу Set
    toMap(): преобразование к типу Map

## 16. Что делает метод reduce?
    Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат
    Метод reduce выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
    Он имеет следующие формы:
    Optional<T> reduce(BinaryOperator<T> accumulator)
    T reduce(T identity, BinaryOperator<T> accumulator)
    U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

    Первая форма возвращает результат в виде объекта Optional<T>. Например, вычислим произведение набора чисел:
    Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
    Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
    System.out.println(result.get()); // 720

    Объект BinaryOperator<T> представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
    возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
    и следующему элементу в наборе бинарную операцию.

    Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
    версию метода reduce(), которая в качестве первого параметра принимает T identity.
    Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

    Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
    String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
    System.out.println(sentence); // Результат: мама мыла раму

    Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
    Для этого используем третью версию метода reduce:

    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));

    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);

    System.out.println(sum); // 117000

## 17. Что делаем метод findFirst?
    Возвращает первый элемент из стрима (возвращает Optional)

## 18. Возможно ли прервать выполнение потока по аналогии с break?
    Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.
    В Java 9 можно использовать takeWhile.
    Лучше использовать итератор:
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;

        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;

        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);

        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }

## 19. Возможно ли пропустить элемент потока по аналогии с continue?
    Вместо этого можно использовать return или filter
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");

        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.

            System.out.println(str); // a c
        });
    }

## 20. Что такое Optional?
    В релизе Java 8 появился новый класс Optional призванный помочь разработчикам в обработке NullPointerException.

    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();

    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);

    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);

    Метод ifPresent() позволяет также устранить некоторую избыточность кода, следующего вида:
     if(person != null) {
    	System.out.println(person);
     }

    Те же действия, но с использованием Optional:
    person.ifPresent(System.out::println);

    orElse(), orElseThrow():
    Как было раньше:
    Person personNew = person != null ? person : new Person();

    То же самое, но с использованием Optional:
    Person personNew = person.orElse(new Person());
    Или, если не хотим создавать объект, можно выбросить исключение:
    Person personNewThrow = person.orElseThrow(Exception::new);

## 21 Перечислите методы Optional?
    Optional.empty() - возвращает Optional с null внутри
    Optional.of(T value) - возвращает Optional с нe null значением внутри
    Optional.ofNullable(T value) - возвращает Optional который может содержать null значение внутри

    Дальше мы рассмотрим методы конкретного объекта optional.
    filter(Predicate<? super T> predicate) - Этот метод дает возможность отфильтровать значение опционального типа.
        Мы передаем ему в параметр Predicat (это стандартный функциональный интерфейс),
        он возвращает булево значение, если значение true, то возвращается этот же опционал, если значение false,
        то возвращается пустой опционал (Optional.empty())
    flatMap(Function<? super T,Optional<U>> mapper) - Этот метод можно применить для изменения значения установленного
        в опционале. Функция которая передается в метод flatMap должна возвращать опционал.
        Если значение не установлено, вернется Optional.empty()
    get() - Этот метод возвращает значение из опционала. Нужно аккуратно использовать этот метод,
        так как он может бросить исключение NoSuchElementException, если значение в опционале равно null.
        Чтобы безопасно использовать этот метод перед его вызовом надо вызвать метод isPresent()
    ifPresent(Consumer<? super T> consumer) - Этот метод исполняет Consumer функциональный интерфейс
        если значение в опционале присутствует
    isPresent() - Возвращает булево значение true если в опционале значение есть и возвращает false если в опционале значение null
    orElse(T other) - Этот метод используется для того, чтобы установить значение по-умолчанию в том случае
        если значение в опционале отсутствует
    orElseThrow(Supplier<? extends X> exceptionSupplier) - Этот метод используется для того, чтобы бросить исключение
        которое передается в метод orElseThrow если значения в опционале не установлено
    orElseGet(Supplier<? extends T> other) - Этот метод полный аналог метода orElse,
        только принимает в себя функциональный интерфейс который должен вернуть значение

## 22. Расскажите про фабричные методы List.of, Set.of, Map.of?
    С приходом Java 9 создавать immutable коллекции намного проще.

    List
    Создание списка выглядит так:

    List<Integer> nums = List.of(1,2,3,4,5);
    Метод of() в интерфейсе List  перегружен и принимает от одного до десяти элементов. Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с varargs

    static <E> List<E> of(E... elements)
    Сделано это с целью оптимизации, так как  при каждом вызове метода c varargs будет создаваться новый массив

    Set

    Set<String> questions = Set.of("What?", "Where?", "When?");
    Set также имеет перегруженные методы, но в отличии от List, если передать дубликат в метод of(), то получим исключение

    Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?

    Map

    Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");
    Последовательности идут парами key, value. Всего таких пар может быть 10, в отличии от List и Set.
    Если в последовательности будут повторения ключей - получим исключение
    Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально

    Вышеупомянутые коллекции нельзя изменить, при попытке получим UnsupportedOperationException;
    В метод of() нельзя передать null, во всех коллекциях получим NullPointerException;
    Метод of() не создает привычные ArrayList, HashSet или HashMap. В Java 9 были созданы специальные ImmutableCollections которые и возвращаются;
    ImmutableCollections являются сериализуемыми, если содержимое тоже является сериализуемым;

## 23 Для чего используется ключевое слово var?
    Одним из самых интересных нововведений Java 10 безусловно является вывод типа локальной переменной (JEP 286).
    Это дает вам возможность сократить объявления переменных используя новое ключевое слово var
    При обработке var, компилятор просматривает правую часть объявления,
    так называемый инициализатор и использует его тип для переменной.
    
## 24 В какие случаях можно использовать var?    
    var - может использоваться только в сочетании с данными.


