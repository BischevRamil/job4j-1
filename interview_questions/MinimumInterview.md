# Вопросы для собеседования минимум

+ [1. Что такое java, характеристики языка](#1-Что-такое-java-характеристики-языка)
+ [2. Что значит высокоуровневый язык программирования](#2-Что-значит-высокоуровневый-язык-программирования)
+ [3. Какие бывают языки программирования](#3-Какие-бывают-языки-программирования)
+ [4. Принципы ООП, как реализована инкапсуляция в Java, полиморфизм](#4-Принципы-ООП-как-реализована-инкапсуляция-в-Java-полиморфизм)
+ [5. Модификаторы доступа](#5-Модификаторы-доступа)
+ [6. Принципы SOLID](#6-Принципы-SOLID)
+ [7. Опишите примитивные типы java](#7-Опишите-примитивные-типы-java)
+ [8. Последовательность инициализации блоков класса и его родителя](#8-Последовательность-инициализации-блоков-класса-и-его-родителя)
+ [9. Классы внутренние, вложенные, абстрактные](#9-Классы-внутренние-вложенные-абстрактные)
+ [10. Замыкания](#10-Замыкания)
+ [11. Методы класса Object](#11-Методы-класса-Object)
+ [12. Ключевое слово volatile? Понятие атомарной операции и как это связано с volatile?](#12-Ключевое-слово-volatile-Понятие-атомарной-операции-и-как-это-связано-с-volatile)
+ [13. Финализация объектов в Java](#13-Финализация-объектов-в-Java)
+ [14. Иерархия коллекций](#14-Иерархия-коллекций)
+ [15. Отличие Set от List, приведите примеры реализаций](#15-Отличие-Set-от-List-приведите-примеры-реализаций)
+ [16. Когда имеет смысл использовать LinkedList вместо ArrayList?](#16-Когда-имеет-смысл-использовать-LinkedList-вместо-ArrayList)
+ [17. Устройство HashMap](#17-Устройство-HashMap)
+ [18. Итераторы. Можно ли удалить элемент из коллекции в итерации цикла по коллекции?](#18-Итераторы-Можно-ли-удалить-элемент-из-коллекции-в-итерации-цикла-по-коллекции)
+ [19. Что такое fail-fast и fail-safe?](#19-Что-такое-fail-fast-и-fail-safe)
+ [20. Механизм сериализации в Java, его внутреннее устройство](#20-Механизм-сериализации-в-Java-его-внутреннее-устройство)
+ [21. Клонирование в Java](#21-Клонирование-в-Java)
+ [22. StringBuffer vs StringBuilder](#22-StringBuffer-vs-StringBuilder)
+ [23. Методы обработки XML документов.](#23-Методы-обработки-XML-документов)
+ [24. Особенности Java 8](#24-Особенности-Java-8)
+ [25. Зачем нужны лямбды?](#25-Зачем-нужны-лямбды)
+ [26. Зачем нужны исключения?](#26-Зачем-нужны-исключения)
+ [27. Иерархия исключений. Отличия checked от unchecked исключений. Назвать некоторые checked и unchecked исключения](#27-Иерархия-исключений-Отличия-checked-от-unchecked-исключений-Назвать-некоторые-checked-и-unchecked-исключения)
+ [28. Как определить свою аннотацию](#28-Как-определить-свою-аннотацию)
+ [29. Зачем нужны immutable объекты](#29-Зачем-нужны-immutable-объекты)
+ [30. Назовите паттерны проектирования, которые вы использовали](#30-Назовите-паттерны-проектирования-которые-вы-использовали)
+ [31. Scope'ы бинов в Spring'e](#31-Scope'ы-бинов-в-Spring'e)
+ [32. Какие книги читали по Java?](#32-Какие-книги-читали-по-Java)
+ [33. Как работает сборщик мусора в Java? Можно ли вызвать сборку мусора.](#33-Как-работает-сборщик-мусора-в-Java-Можно-ли-вызвать-сборку-мусора)
+ [34. Как устроена память в Java?](#34-Как-устроена-память-в-Java)
+ [35. В какой области памяти хранятся локальные переменные и объекты?](#35-В-какой-области-памяти-хранятся-локальные-переменные-и-объекты)
+ [36. Написать код, который 100% приведет к OutOfMemoryError, а также к StackOverflowException](#36-Написать-код-который-100%-приведет-к-OutOfMemoryError-а-также-к-StackOverflowException)
+ [37. Что такое happens-before? Приведите примеры.](#37-Что-такое-happens-before-Приведите-примеры)
+ [38. Что такое deadlock? Как его избежать?](#38-Что-такое-deadlock-Как-его-избежать)
+ [39. Что такое состояние гонок?](#39-Что-такое-состояние-гонок)
+ [40. Что такое Executor'ы? Зачем они нужны?](#40-Что-такое-Executor'ы-Зачем-они-нужны)
+ [41. В чем отличия между equals и ==? Контракты по equals и hashcode.](#41-В-чем-отличия-между-equals-и-==-Контракты-по-equals-и-hashcode)
+ [42. написать реализацию equals и хеш-код для произвольного класса](#42-написать-реализацию-equals-и-хеш-код-для-произвольного-класса)
+ [43. Что такое дерево? Можно ли сделать так, чтобы обычное двоичное дерево выродилось в связный список?](#43-Что-такое-дерево-Можно-ли-сделать-так-чтобы-обычное-двоичное-дерево-выродилось-в-связный-список)
+ [44. Какие есть способны конфигурирования ApplicationContext Spring'a.](#44-Какие-есть-способны-конфигурирования-ApplicationContext-Spring'a)
+ [45. Как в Spring заинжектить два бина одного типа?](#45-Как-в-Spring-заинжектить-два-бина-одного-типа)
+ [46. Что такое SpringBoot](#46-Что-такое-SpringBoot)
+ [47. Принципы организации многопоточности в java](#47-Принципы-организации-многопоточности-в-java)
+ [48. Как запустить поток?](#48-Как-запустить-поток)
+ [49. Состояния потоков](#49-Состояния-потоков)
+ [50. SQL](#50-SQL)
+ [51. Транзакции. ACID. Феномены чтения.](#51-Транзакции-ACID-Феномены-чтения)
+ [53. Что такое Maven?](#53-Что-такое-Maven)
+ [53. Что такое область видимости зависимостей DEPENDENCY SCOPE в Maven?](#53-Что-такое-область-видимости-зависимостей-DEPENDENCY-SCOPE-в-Maven)
+ [54. Какие вы знаете репозитории Maven](#54-Какие-вы-знаете-репозитории-Maven)
+ [55. Внутреннее устройство хранилища git](#55-Внутреннее-устройство-хранилища-git)
+ [56. Сервлеты. JSP](#56-Сервлеты-JSP)
+ [57. Spring core](#57-Spring-core)
+ [58. Spring MVC](#58-Spring-MVC)
+ [59. JPA](#59-JPA)
+ [60. Hibernate](#60-Hibernate)
+ [61. Способы аутентификации пользователя](#61-Способы-аутентификации-пользователя)
+ [62. Паттерны. Написать реализацию паттерна Singleton. Abstract Factory vs factory method.](#62-Паттерны-Написать-реализацию-паттерна-Singleton-Abstract-Factory-vs-factory-method)
+ [63. How to define immutable object](#63-How-to-define-immutable-object)

## 1 Что такое java характеристики языка

+ ООП.
+ Строгая типизация.
+ По умолчанию запрет прямого доступа к памяти (исключение sun.misc.Unsafe).
+ Нет множественного наследования классов. Вместо этого интерфейсы.
+ Write once, run anywhere. Не зависит от ОС. Т.к. исползуется JVM.
+ Особенность ява, связанная с транслированием в байт-код, положительно сказывается и на производительности.
+ Многопоточный.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 2 Что значит высокоуровневый язык программирования

Высокоуровневые языки программирования были разработаны для платформенной независимости сути алгоритмов. 
Зависимость от платформы перекладывается на инструментальные программы — трансляторы, компилирующие текст, 
написанный на языке высокого уровня, в элементарные машинные команды (инструкции).

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 3 Какие бывают языки программирования

+ Объектно-ориентированные.
+ Процедурные. Процедуры меняют какое-то общее состояние. 
Процедурный стиль - это использование операторов последовательного исполнения, ветвления и безусловного перехода
```javascript
const array = ['first', 'second'];

let output;

function allOdd(words) {
  let result = true;

  for (let i = 0; i < words.length; ++i) {
    const len = words[i].length;

    if (len % 2 !== 0) {
      result = false;
      break;
    }
  }

  return result;
}

output = allOdd(array);

alert(output);
```
+ Функциональные. ФП не предполагает наличия изменяемого состояния. 
Функциональный стиль - это использование только суперпозиции функций.
 ```javascript
 function length(string) {
   return prop('length', string);
 }
 
 function odd(number) {
   return equals(modulus(number, 2), 0); 
 }
 
 function allOdd(...words) {
   return every(compose(odd, length), words);
 }
 
 alert(allOdd('first', 'second'));
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 4 Принципы ООП как реализована инкапсуляция в Java полиморфизм

+ *Абстракция* - выделение значимой информации и исключение из рассмотрения незначимой. В Java: через классы.
+ *Инкапсуляция* - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». В Java: Используются модификаторы доступа public, private, package;
+ *Наследование* - cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. 
Класс, от которого производится наследование, называется базовым, родительским или суперклассом. В Java: Extends, Impliments;
+ *Полиморфизм* - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. В Java: через интерфейсы;

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 5 Модификаторы доступа

+ private (закрытый) — доступ к члену класса не предоставляется никому, кроме методов этого класса. 
Другие классы того же пакета также не могут обращаться к private-членам.
+ default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует — 
член класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.
Т.е. если package2.Class2 extends package1.MainClass, то в Class2 методы без идентификатора из MainClass видны не будут.
+ protected (защищённый) — доступ в пределах пакета и классов наследников. 
Доступ в классе из другого пакета будет к методам public и protected главного класса. 
Т.е. если package2.Class2 extends package1.MainClass, то внутри package2.Class2 методы с идентификатором protected из MainClass будут видны.
+ public (открытый) — доступ для всех из любого другого кода проекта
+ Модификаторы в списке расположены по возрастающей видимости в программе.
+ Во время наследования возможно изменения модификаторов доступа в сторону большей видимости. 
Так сделано для того, чтобы не нарушался принцип LSP для наследуемого класса.
protected -> public
package -> protected, public

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 6 Принципы SOLID

+ S - Принцип единственной ответственности.  Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.
+ O - Принцип открытости закрытости. Класс должен быть открыт для расширения и закрыт для изменения.
+ L - Принцип подстановки Барбары Лисков. объекты в программе можно заменить их наследниками без изменения свойств программы.
+ I - Принцип разделения интерфейса. Много интерфейсов специального назначения лучше, чем один интерфейс общего назначения.
+ D - Принцип подстановки зависимостей. Зависимость на абстракцию. Нету зависимости на конкретную реализацию.

[SOLID](https://github.com/a11exe/job4j/blob/master/interview_questions/SOLID.md)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 7 Опишите примитивные типы java

+ byte - 1 байт (8 бит). Мин -2^7 макс 2^7-1
+ short - 2 байта (16 бит). Мин -2^15 Макс 2^15-1
+ char - 2 байта (16 бит). 2^16-1
+ int - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
+ long - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
+ float - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
+ double - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
+ boolean - по спецификации не определен в среднем 1 байт

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 8 Последовательность инициализации блоков класса и его родителя

+ Сначала вызываются все статические блоки от первого предка до последнего наследника. 
+ Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка). 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 9 Классы внутренние вложенные абстрактные

*Особенности абстрактных классов:*
+ Если есть хоть один абстрактный метод, то класс должен быть абстрактным. 
+ Абстрактные классы нельзя создавать с помощью new, но можно использовать в качестве ссылки, для полиморфизма.

*Вложенный класс (nested classes.)*
+ Non-static nested classes — нестатические вложенные классы. По-другому их еще называют inner classes — внутренние классы.
+ Static nested classes — статические вложенные классы.

*Внутренний класс (inner classes)*
+ локальным классом (local class)
+ анонимным классом (anonymous class)

![Вложенные классы](https://github.com/a11exe/job4j/blob/master/interview_questions/nested.png)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 10 Замыкания

Лямбда-выражения Java 8 — это замыкания.
Что такое замыкание?
При замыкании используются переменные, расположенные вне области действия функции.
local variables referenced from a lambda expression must be final or effectively final 
(локальные переменные, на которые ставится ссылка из лямбда-выражения, 
должны быть финальными или фактически финальными).

Оказывается, что лямбда-выражения в Java замыкаются только вокруг значений, но не вокруг переменных. 
Java требует, чтобы эти значения были неизменны, как если бы мы объявили их final. 
Итак, они должны быть final независимо от того, объявляли вы их таким образом или нет. 
То есть, «фактически финальными». Поэтому в Java есть «замыкания с ограничениями», 
а не «полноценные» замыкания, которые, тем не менее, довольно полезны.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 11 Методы класса Object

+ public final native Class getClass() — возвращает в рантайме класс данного объекта.
+ public native int hashCode() — возвращает хеш-код
+ public boolean equals(Object obj) — сравнивает объекты.
+ protected native Object clone() throws CloneNotSupportedException — клонирование объекта
+ public String toString() — возвращает строковое представление объекта.
+ public final native void notify() — просыпается один поток, который ждет на “мониторе” данного объекта.
+ public final native void notifyAll() — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
+ public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
+ public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
+ public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
+ protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 12 Ключевое слово volatile Понятие атомарной операции и как это связано с volatile

**volatile** - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. 
Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут!

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 13 Финализация объектов в Java

Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 14 Иерархия коллекций

+ i Collections extends Iterable.
+ \- i Set (коллекция без дублирования)
+ -- HashSet базирующаяся на HashMap В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object())
+ --- LinkedHashSet в основе лежит LinkedHashMap
+ -- i SortedSet Методы: first, last
+ --- TreeSet (отсортированный список) содержит в себе объект NavigableMap
+ \- i Queue очередь Методы: offer(), element(), peek(), poll(), remove()
+  -- i Deque двусторонняя очередь addFirst, addLast, getFist, getLast, (push, pop  -> использовать как стек)
+ \- i List упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно повторяющиеся, можно по значению первый найденный)
+ -- Vector @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента
+ -- Stack - данная коллекция является расширением коллекции Vector. реализация стека LIFO
+ -- ArrayList динамический массив, можно хранить null
+ -- LinkedList связный список (impl List & Deque)
+ i Map (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) get(), put(), entrySet(), keySet(), values()
+ \- i SortedMap (по порядку нарастания ключей)
+ \- i NavigableMap
+ -- TreeMap реализация Map основанная на красно-чёрных деревьях (отсортированная по умолчанию natural odering, можно задать свой компаратор)
+ \- AbstractMap
+ -- HashMap позволяет использовать null как в качестве ключа, так и значения
+ --- LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично LinkedList
+ \- WeekHashMap - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 15 Отличие Set от List приведите примеры реализаций

+ **Set** - Множество. (Здесь могут храниться только уникальные значения, нет дубликатов)
+ **Queue (Deque)** - Очередь. FIFO (Первый вошел, первый вышел). реализуется LinkedList'ом
+ **List** - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)
+ **Map** - (от Collection он не наследуется) Значения хранятся как пара - ключ-значение. и по ключу получаем значение.
у мапы нету итератора

+ **List**: ArrayList, LinkedList
+ **Set**: HashSet, LinkedHashSet, TreeSet
+ **Map**: HashMap, LinkedHashMap, TreeMap

+ **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
+ **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

сет это список ключей от мапы

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 16 Когда имеет смысл использовать LinkedList вместо ArrayList

**ArrayList** реализован на массивах. (используют если чаще читаются элементы, чем добавляются)
Хранит свои элементы в массиве.
+ \+ осуществляется быстрый поиск элементов.
+ \+ меньше расхходует памятина хранение элементов
+ \- увеличение ArrayList'a происходит медленно.
+ \- при вставке элемента (или удалении) в середину или в начало, приходится переписывать все элементы.

**LinkedList** является представителем двунаправленного списка. (цепочка) 
(используется если элементы чаще добавляются чем читаются)
Хранит свои элементы в обектах у которых есть ссылки на предыдущий и следующий элементы.
+ \+ быстрая вставка и удаление в середину списка (переписать next и prev и всё)
+ \- долгий поиск в середине (нужно перебрать все элементы)

в среднем, сложности одинаковые. Но я бы не стал рекомендовать использовать LinkedList,
за исключением ситуации когда, преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 17 Устройство HashMap

HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива, 
которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, 
на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. 
Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, 
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, 
от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, 
то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время. Вроде все здорово, с одной оговоркой, 
хеш-функций должна равномерно распределять элементы по корзинам, 
в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 18 Итераторы Можно ли удалить элемент из коллекции в итерации цикла по коллекции

Удалять надо используя итератор для обхода. Иначе будет ConcurrentModificationException.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 19 Что такое fail fast и fail safe

Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.

Важно отметить, что fail-fast итераторы работают на основе принципа "по мере возможности", 
то есть не дается никаких гарантий генерации исключения ConcurrentModificationException в случае конкурентной модификации. 
Так что полагаться на это не стоит – скорее, их следует использовать для обнаружения ошибок. 
Большинство неконкурентных коллекций предоставляют fail-fast итераторы.

fail-safe итераторы используются в конкурентных коллекциях ConcurrentHashMap

+ Они могут обрабатываться конкурентно с другими операциями
+ Они никогда не генерируют исключение ConcurrentModificationException
+ Они гарантированно обходят существовавшие на момент создания итератора элементы ровно один раз, и могут (но не обязаны) отражать последующие модификации.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 20 Механизм сериализации в Java его внутреннее устройство

Сериализация объекта это способность объекта сохранять полную копию его и любых других объектов на которые он ссылается, 
используя поток вывода (например, во внешний файл). 
Главным образом это происходит автоматически благодаря классам ObjectInputStream и ObjectOutputStream. 
Программист может решить реализовать эту функцию, путем реализации интерфейса Serializable при создании класса.

Процесс сериализиции также известен как маршалинг объекта, десериализация же известна как демаршалинг.
параметр класса объявленный как transient, не сериализуются

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 21 Клонирование в Java

Можно использовать конструктор копирования.

В Java это означает возможность создавать объект с аналогичной структурой, как и у исходного объекта. 
Метод clone() обеспечивает эту функциональность.

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. 
По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. 
*При клонировании, JVM делает такие вещи:*   
+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. 
Следовательно, оба объекта будут иметь одинаковые ссылки.
Глубокое копирование дублирует все. 
Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. 
Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию. 

*Глубокое клонирование требует выполнения следующих правил:*
+ Нет необходимости копировать отдельно примитивные данные;
+ Все классы-члены в оригинальном классе должны поддерживать клонирование. 
Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
+ Если какой-либо член класса не поддерживает клонирование, 
то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, 
по одному.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 22 StringBuffer vs StringBuilder

StringBuffer is synchronized, StringBuilder is not.
StringBuilder is faster than StringBuffer because it's not synchronized.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 23 Методы обработки XML документов

+ DOM - обход XML документа в оба направлениях, грузит весь документ в память подходит для небольших файлов.
+ Stax - событийный, грузит документ частями, подходит для мелких документов. работает по пул модели. 
Позволяет обрабатывать только те события которые нам необходимы. позволяет писать в XML файл.
+ Sax - событийный, грузит документ частями, позволяет работать с большими документам, 
работает по пуш модели необходимо обрабатывать все события

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 24 Особенности Java 8

+ Лямбды и Функциональные интерфейсы
+ Интерфейсы по умолчанию и статические методы
+ Ссылочные методы cars.forEach( Car::repair )

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 25 Зачем нужны лямбды

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, 
поэтому он может быть выполнен позже, один или несколько раз.
Короче говоря, они позволяют написать метод и сразу же использовать его. 
Особенно полезно в случае однократного вызова метода, т.к. сокращает время на объявление и написание метода без
необходимости создавать класс.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 26 Зачем нужны исключения

Раньше использовались коды возврата:

+ Нельзя было пробрасывать между методами. Приходилось обрабатывать в каждом.
+ Не всегда можно было точно понять какая конкретно ошибка.

На стадии разработки программы мы «ограждаем» опасные участки кода в отношении исключений с помощью блока try{}, 
предусматриваем «запасные» пути с помощью блока catch{}, 
в блоке finally{} мы пишем код, который выполняется в программе при любом исходе.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 27 Иерархия исключений Отличия checked от unchecked исключений Назвать некоторые checked и unchecked исключения

Все исключения наследуются от Throwable.

+ Error (unchecked)- восстановление дальнейшей нормальной работы программы невозможно. 
+ Exception
++ RuntimeException (unchecked) - NPE, ClasCastEx, 
++ Checked Exception (checked) - IOEx, SQLEx

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 28 Как определить свою аннотацию

Аннотации используются для анализа кода, компиляции или выполнения. 
Аннотированы могут быть пакеты, классы, методы, переменные и параметры.

Для этого вам нужно создать новый тип, который использует Java тип @interface, 
который будет содержать элементы, которые в свою очередь определяют детали метаданных.

 ```java
public @interface About{
    String info() default "";
}
 ```
 
[к оглавлению](#Вопросы-для-собеседования-минимум)

## 29 Зачем нужны immutable объекты

Неизменяемые объекты можно свободно использовать одновременно из разных нитей.
Обычно immutable классы содержат различные методы, которые «как бы» меняют объект, 
но вместо изменения самого объекта эти методы просто создают новый объект и возвращают его.

В случае же immutable-объекта объект после окончания конструктора не изменяется вообще. 
Одного лишь модификатора final для этого недостаточно, необходимо, чтобы все подбъекты были тоже неизменяемыми. 
Вы в принципе можете держать внутри ссылку на изменяемый объект, но обращаться с ним так, чтобы он не менялся.

неизменяемые объекты не требуют синхронизации при многопоточном доступе.

To create an immutable class in java, you have to do following steps.

+ Declare the class as final so it can’t be extended.
+ Make all fields private so that direct access is not allowed.
+ Don’t provide setter methods for variables
+ Make all mutable fields final so that it’s value can be assigned only once.
+ Initialize all the fields via a constructor performing deep copy.
+ Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 30 Назовите паттерны проектирования которые вы использовали

+ *Builder* - StringBulider
+ *Factory Method* - Calendar calendar = Calendar.getInstance(); 
(Если мы посмотрим в конструктор, то увидим, что в зависимости от условий создаются разные реализации Calendar)
+ *Singleton* - Изначально, как замена глобальным переменным. Он один и следовательно все обращения к нему несут изменения во всём проекте. 
В одном месте вы создали подключение к базе и дальше можете уже использовать его в любой части программы, 
не пересоздавая подключение и не передавая каждый раз его как аргумент функции.
+ *Decorator (Wrapper)* - декоратор оборачивается вокруг чего-то, что передали на вход. 
Было побайтовое чтение, раз и добавили оберткой буферизацию, а потом еще что-нибудь
+ *Adapter* - Он похож на декоратор — на вход декоратор принимает один объект и возвращает обёртку над этим объектом. 
Отличие в том, что цель у этого не изменение функционала, а адаптация одного интерфейса к другому. 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 31 Scope'ы бинов в Spring'e

+ *singleton* Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
+ *prototype* Позволяет иметь любое количество экземпляров бина.
+ *request* Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext.
+ *session* Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext.
+ *global-session* Создаётся один экземпляр бина на каждую глобальную HTTP сессию. Касается исключительно ApplicationContext.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 32 Какие книги читали по Java



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 33 Как работает сборщик мусора в Java Можно ли вызвать сборку мусора



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 34 Как устроена память в Java



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 35 В какой области памяти хранятся локальные переменные и объекты



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 36 Написать код который 100% приведет к OutOfMemoryError а также к StackOverflowException



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 37 Что такое happens before Приведите примеры



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 38 Что такое deadlock Как его избежать



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 39 Что такое состояние гонок



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 40 Что такое Executor'ы Зачем они нужны



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 41 В чем отличия между equals и == Контракты по equals и hashcode



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 42 написать реализацию equals и хеш код для произвольного класса



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 43 Что такое дерево Можно ли сделать так чтобы обычное двоичное дерево выродилось в связный список



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 44 Какие есть способны конфигурирования ApplicationContext Spring'a



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 45 Как в Spring заинжектить два бина одного типа



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 46 Что такое SpringBoot



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 47 Принципы организации многопоточности в java



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 48 Как запустить поток



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 49 Состояния потоков



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 50 SQL



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 51 Транзакции ACID Феномены чтения



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 53 Что такое Maven



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 53 Что такое область видимости зависимостей DEPENDENCY SCOPE в Maven



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 54 Какие вы знаете репозитории Maven



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 55 Внутреннее устройство хранилища git



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 56 Сервлеты JSP



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 57 Spring core



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 58 Spring MVC



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 59 JPA



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 60 Hibernate



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 61 Способы аутентификации пользователя



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 62 Паттерны Написать реализацию паттерна Singleton Abstract Factory vs factory method



[к оглавлению](#Вопросы-для-собеседования-минимум)

## 63 How to define immutable object



[к оглавлению](#Вопросы-для-собеседования-минимум)